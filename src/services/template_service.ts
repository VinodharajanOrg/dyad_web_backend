import * as fs from 'fs';
import * as path from 'path';
import { promises as fsPromises } from 'fs';
import { logger } from '../utils/logger';

export class TemplateService {
  private templatesDir: string;

  constructor() {
    // In production (Docker), scaffold is at /app/scaffold
    // In development, it's at backend/../scaffold relative to dist or src
    if (process.env.NODE_ENV === 'production') {
      this.templatesDir = '/app/scaffold';
    } else {
      this.templatesDir = path.resolve(__dirname, '../../scaffold');
    }
  }

  /**
   * Get available templates
   */
  async getTemplates(): Promise<Array<{ id: string; name: string; description: string }>> {
    return [
      {
        id: 'vite-react-shadcn',
        name: 'Vite + React + shadcn/ui',
        description: 'Modern React app with Vite, TypeScript, Tailwind CSS, and shadcn/ui components',
      },
      {
        id: 'blank',
        name: 'Blank',
        description: 'Empty project (files will be generated by AI)',
      },
    ];
  }

  /**
   * Copy template files to app directory
   */
  async copyTemplate(templateId: string, targetPath: string): Promise<void> {
    if (templateId === 'blank') {
      // Just create the directory
      await fsPromises.mkdir(targetPath, { recursive: true });
      logger.info('Created blank app directory', { service: 'template', targetPath });
      return;
    }

    if (templateId === 'vite-react-shadcn') {
      // Check if scaffold directory exists
      if (!fs.existsSync(this.templatesDir)) {
        throw new Error(`Template directory not found: ${this.templatesDir}`);
      }

      // Create target directory
      await fsPromises.mkdir(targetPath, { recursive: true });

      // Copy all files from scaffold to target
      await this.copyDirectory(this.templatesDir, targetPath);

      logger.info('Copied template', { service: 'template', templateId, targetPath });
    } else {
      throw new Error(`Unknown template: ${templateId}`);
    }
  }

  /**
   * Recursively copy directory contents
   */
  private async copyDirectory(source: string, destination: string): Promise<void> {
    // Create destination directory
    await fsPromises.mkdir(destination, { recursive: true });

    // Read source directory
    const entries = await fsPromises.readdir(source, { withFileTypes: true });

    for (const entry of entries) {
      const sourcePath = path.join(source, entry.name);
      const destPath = path.join(destination, entry.name);

      // Skip node_modules, .git, dist, and other build artifacts
      if (this.shouldSkipFile(entry.name)) {
        continue;
      }

      if (entry.isDirectory()) {
        // Recursively copy subdirectory
        await this.copyDirectory(sourcePath, destPath);
      } else {
        // Copy file
        await fsPromises.copyFile(sourcePath, destPath);
      }
    }
  }

  /**
   * Check if file/directory should be skipped during copy
   */
  private shouldSkipFile(name: string): boolean {
    const skipPatterns = [
      'node_modules',
      '.git',
      '.DS_Store',
      'dist',
      'build',
      '.vite',
      '.turbo',
      'pnpm-lock.yaml', // We'll let pnpm regenerate this
      'package-lock.json',
      'yarn.lock',
    ];

    return skipPatterns.includes(name);
  }

  /**
   * Update package.json with custom app name
   */
  async updatePackageJson(appPath: string, appName: string): Promise<void> {
    const packageJsonPath = path.join(appPath, 'package.json');

    if (fs.existsSync(packageJsonPath)) {
      const content = await fsPromises.readFile(packageJsonPath, 'utf-8');
      const packageJson = JSON.parse(content);

      // Update name
      packageJson.name = appName.toLowerCase().replace(/\s+/g, '-');

      // Write back
      await fsPromises.writeFile(
        packageJsonPath,
        JSON.stringify(packageJson, null, 2),
        'utf-8'
      );

      logger.info('Updated package.json', { service: 'template', packageName: packageJson.name });
    }
  }
}
